name: Deploy to Hetzner

on:
  push:
    branches:
      - main
  workflow_dispatch:  # Allow manual deployment

env:
  NODE_VERSION: '20'
  PYTHON_VERSION: '3.11'

jobs:
  test:
    name: Run Tests
    runs-on: ubuntu-latest

    services:
      postgres:
        image: postgres:16-alpine
        env:
          POSTGRES_USER: yogaflow
          POSTGRES_PASSWORD: testpassword
          POSTGRES_DB: yogaflow_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'
          cache-dependency-path: backend/requirements.txt

      - name: Install backend dependencies
        working-directory: backend
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Run backend tests
        continue-on-error: true
        env:
          DATABASE_URL: postgresql+asyncpg://yogaflow:testpassword@localhost:5432/yogaflow_test
          SECRET_KEY: test-secret-key-for-ci
          ENVIRONMENT: testing
          PYTHONPATH: ${{ github.workspace }}/backend
        run: |
          cd backend
          pytest -v

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Install frontend dependencies
        working-directory: frontend
        run: npm ci

      - name: Run frontend tests
        continue-on-error: true
        working-directory: frontend
        run: npm test -- --run

  build:
    name: Build Application
    runs-on: ubuntu-latest
    needs: test

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Build frontend
        working-directory: frontend
        env:
          VITE_API_URL: ${{ secrets.VITE_API_URL }}
        run: |
          npm ci
          npm run build

      - name: Upload frontend build
        uses: actions/upload-artifact@v4
        with:
          name: frontend-dist
          path: frontend/dist
          retention-days: 1

  deploy:
    name: Deploy to Hetzner
    runs-on: ubuntu-latest
    needs: build
    environment: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download frontend build
        uses: actions/download-artifact@v4
        with:
          name: frontend-dist
          path: frontend/dist

      - name: Set up SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.HETZNER_SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.HETZNER_SERVER_IP }} >> ~/.ssh/known_hosts

      - name: Create deployment package
        run: |
          tar -czf deployment.tar.gz \
            backend/ \
            frontend/dist/ \
            docker-compose.prod.yml \
            infrastructure/hetzner/

      - name: Copy files to server
        run: |
          scp deployment.tar.gz deploy@${{ secrets.HETZNER_SERVER_IP }}:/tmp/

      - name: Deploy application
        run: |
          ssh deploy@${{ secrets.HETZNER_SERVER_IP }} << 'ENDSSH'
            set -e

            # Stop system Nginx if running (Docker will handle web serving)
            if sudo systemctl is-active --quiet nginx; then
              echo "Stopping system Nginx to free ports 80/443 for Docker..."
              sudo systemctl stop nginx
              sudo systemctl disable nginx
            fi

            # Navigate to application directory
            cd /opt/yogaflow

            # Stop containers before extracting new files
            if [[ -f docker-compose.prod.yml ]]; then
              echo "Stopping existing containers..."
              docker compose -f docker-compose.prod.yml down || true
            fi

            # Extract deployment package
            tar -xzf /tmp/deployment.tar.gz
            rm /tmp/deployment.tar.gz

            # Check if SSL certificates exist, if not, create directory and generate them
            if [[ ! -f /opt/yogaflow/ssl/nginx-selfsigned.crt ]]; then
              echo "Generating self-signed SSL certificates..."
              mkdir -p /opt/yogaflow/ssl
              openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
                -keyout /opt/yogaflow/ssl/nginx-selfsigned.key \
                -out /opt/yogaflow/ssl/nginx-selfsigned.crt \
                -subj "/C=DE/ST=Hessen/L=Falkenstein/O=YogaFlow/OU=IT/CN=yogaflow.local"
              chmod 644 /opt/yogaflow/ssl/nginx-selfsigned.crt
              chmod 600 /opt/yogaflow/ssl/nginx-selfsigned.key
              echo "✓ SSL certificates generated"
              ls -lh /opt/yogaflow/ssl/
            else
              echo "✓ SSL certificates already exist"
              ls -lh /opt/yogaflow/ssl/
            fi

            # Pull latest images
            docker compose -f docker-compose.prod.yml pull

            # Build and deploy with zero-downtime
            docker compose -f docker-compose.prod.yml up -d --build --remove-orphans

            # Wait for services to be healthy
            echo "Waiting for services to be healthy..."
            sleep 10

            # Check backend health
            for i in {1..30}; do
              if docker exec yogaflow-backend curl -f http://localhost:8000/health > /dev/null 2>&1; then
                echo "Backend is healthy!"
                break
              fi
              echo "Waiting for backend... ($i/30)"
              sleep 2
            done

            # Clean up old images
            docker image prune -af --filter "until=24h"

            echo "Deployment completed successfully!"
          ENDSSH

      - name: Verify deployment
        run: |
          # Wait for application to be fully ready
          sleep 5

          # Check if the application is responding
          curl -f https://${{ secrets.HETZNER_SERVER_IP }}/health || \
          curl -f http://${{ secrets.HETZNER_SERVER_IP }}/health

      - name: Notify deployment status
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "✅ Deployment successful!"
          else
            echo "❌ Deployment failed!"
          fi

  cleanup:
    name: Cleanup Artifacts
    runs-on: ubuntu-latest
    needs: deploy
    if: always()

    steps:
      - name: Delete artifacts
        uses: geekyeggo/delete-artifact@v5
        with:
          name: frontend-dist
          failOnError: false
